<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=0.7">
    <title>(˵ ͡° ͜ʖ ͡°˵)</title>
    <link rel="icon" href="assets/favicon.ico">
    <link rel="stylesheet" type="text/css" href="style.css">
    
    <style>
        #canvasContainer { margin-top: 1rem; }
        canvas { border: 1px solid #000; background: #fff; display: block; }
        
        /* CSS Consolidado: aplica los estilos a todos los controles */
        .control-element {
            font-family: "Times New Roman", Times, serif;
            font-size: 11pt;
            letter-spacing: -0.3px;
            background: none;
            border: none;
            color: black;
            text-decoration: underline;
            cursor: pointer;
            padding: 0;
        }
        
        #gallery { 
            margin-top:1rem; 
            display:grid; 
            /* Uso de 'auto-fit' y minmax para un grid responsivo más robusto */
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); 
            gap:10px; 
        }
        #gallery img { 
            width: 100%; /* Asegura que la imagen llene el espacio del grid */
            height: auto;
            border:1px solid #ccc; 
        }
        .text { margin-bottom: 1rem; }
    </style>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-F9YHR26YNQ"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-F9YHR26YNQ');
    </script>
    
</head>
<body>
    <div id="content">
        <div class="container">
            <div class="text">
                <a href='index' id="home-link">*</a><br>
                ✎ what's on your mind?
            </div>
        </div>
    </div>

    <div id="canvasContainer">
        <canvas id="drawCanvas" width="500" height="500"></canvas>

        <div style="margin-top:10px; display:flex; gap:8px; align-items:flex-start; flex-wrap:wrap;">
            <button id="eraserBtn" type="button" class="control-element">eraser size >> </button>
            <input id="eraserSize" type="range" min="4" max="60" value="20" />
            <select id="colorPicker" class="control-element"> 
                <option value="#000000">black</option>
                <option value="#ff0000">red</option>
                <option value="#0000ff">blue</option>
                <option value="#00e31a">green</option>
                <option value="#ffff00">yellow</option>
            </select>
            <br>
            <button id="downloadBtn" type="button" class="control-element">send! (I want to be a proud collector)</button>
        </div>

        
        <div id="gallery"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js"></script>
    <script>
        emailjs.init({ publicKey: "l06doB2wxnGk4vSmz" });

        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d');
        
        // **[ELIMINADA]** Lógica redundante touchstart/touchmove.
        // Los 'pointer events' manejan correctamente el dibujo táctil y el scroll.

        const btn = document.getElementById('downloadBtn');
        const eraserBtn = document.getElementById('eraserBtn');
        const eraserSizeInput = document.getElementById('eraserSize');
        const colorPicker = document.getElementById('colorPicker');

        let currentColor = "#000000";
        let eraserMode = false;

        // Cambiar color y modo borrador
        colorPicker.addEventListener('change', e => {
            currentColor = e.target.value;
            eraserMode = false;
            eraserBtn.textContent = "eraser size >>";
        });

        eraserBtn.addEventListener('click', () => {
            eraserMode = !eraserMode;
            eraserBtn.textContent = eraserMode ? "(ON) eraser size >>" : "eraser size >>";
        });


        let isPointerDown = false;
        let lastPos = null;

        // Simplificado para confiar en las coordenadas de los 'pointer events'
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            // Ya no revisamos e.touches porque los pointer events son unificados
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        function drawLine(from, to, size, erase) {
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.lineWidth = size;
            if (erase) {
                ctx.globalCompositeOperation = 'destination-out';
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = currentColor;
            }
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();
            ctx.closePath();
            if (erase) {
                // Para asegurar que un clic puntual borre algo
                ctx.beginPath();
                ctx.arc(to.x, to.y, size/2, 0, Math.PI * 2);
                ctx.fill();
                ctx.closePath();
            }
        }

        canvas.addEventListener('pointerdown', e => {
            isPointerDown = true;
            lastPos = getPos(e);
            // El tamaño del lápiz en modo normal es 2
            const size = eraserMode ? Number(eraserSizeInput.value) : 2; 
            drawLine(lastPos, lastPos, size, eraserMode);
            canvas.setPointerCapture(e.pointerId);
        });

        canvas.addEventListener('pointermove', e => {
            if (!isPointerDown) return;
            const pos = getPos(e);
            const size = eraserMode ? Number(eraserSizeInput.value) : 2;
            drawLine(lastPos, pos, size, eraserMode);
            lastPos = pos;
        });

        canvas.addEventListener('pointerup', e => {
            isPointerDown = false;
            lastPos = null;
            try { canvas.releasePointerCapture(e.pointerId); } catch(_) {}
        });

        
        const gallery = document.getElementById("gallery");
        const savedImages = JSON.parse(localStorage.getItem("galleryImages") || "[]");

        savedImages.forEach(src => {
            const img = document.createElement("img");
            img.src = src;
            if (gallery) gallery.appendChild(img);
        });

        btn.addEventListener('click', async () => {
            const dataURL = canvas.toDataURL("image/png");

            const img = document.createElement("img");
            img.src = dataURL;
            if (gallery) gallery.appendChild(img);
            savedImages.push(dataURL);
            localStorage.setItem("galleryImages", JSON.stringify(savedImages));

            const params = {
                to_email: "casfemarta@gmail.com",
                message: "para descargar en .png primero guardar en Google Fotos y de ahí descargar",
                attachment: dataURL
            };

            btn.disabled = true;
            btn.textContent = "sending...";

            try {
                await emailjs.send("service_o3jmvle", "template_r72a0hl", params);
                alert("éxito rotundo");
            } catch (err) {
                console.error("Error detallado:", err);
                alert(" E R R O R ");
            } finally {
                btn.disabled = false;
                btn.textContent = "send another!";
            }
        });
    </script>
</body>
</html>
